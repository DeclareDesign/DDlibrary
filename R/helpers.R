#' Get code from a designer
#' Simply takes the attribute "code", if it is present
#' 
#' @param design A function that pulls code atribute from design.
#' @return Verbatim code 
#' @export
#' 
#'
get_design_code <- function(design) attr(design, "code")


#' @export
find_triple_bracket <- function(f){
  
  pred <- function(expr, depth=3) {
    (depth == 0) || (
      length(expr) > 1 &&
        expr[[1]] == as.symbol('{') &&
        Recall(expr[[2]], depth - 1)
    )
  }
  
  clean <- function(ch, n=length(ch)-1) ch[2:n]
  
  ret <- Filter(pred, body(f))
  
  if(length(ret) == 0) "" else clean(deparse(ret[[1]][[2]][[2]]))
  
}



#' @export
construct_design_code <- function(designer, args, exclude_args = NULL){
  # get the code for the design 
  txt <- as.character(getSrcref(designer))
  if(length(txt)==0){
    txt <- find_triple_bracket(designer)
  }else{
    open <- grep("[{]{3}", txt)
    close <- grep("[}]{3}", txt)
    
    if(length(open) != 1) stop("could not find opening tag in ", substitute(designer))
    if(length(close) != 1) stop("could not find opening tag in ", substitute(designer))
    txt <- txt[seq(open + 1, close - 1)]
  }
  
  indentation <- strsplit(txt[1], "")[[1]]
  indentation <- indentation[cumprod(indentation == " ") == 1]
  indentation <- paste0("^", paste(indentation, collapse=""))
  
  code <- sub(indentation, "", txt)
  
  # Get names of arguments   
  arg_names <- names(args[-1])

    # Evaluate args in order provided in formals
  for(j in 1:length(arg_names)) eval(parse(text = paste(arg_names[j], " <- ", args[arg_names[j]])))  
  arg_vals = sapply(arg_names, function(x) eval(parse(text = paste0("c(", paste(x, collapse = ","), ")"))))

  # convert args to text
  args_text <- paste(sapply(arg_names, function(x) paste(x, "<-",     arg_vals[x])))

  # optionally exclude arguments
  if(!is.null(exclude_args)) args_text <- args_text[!(arg_names%in%exclude_args)]

  # add arguments and code
  c(args_text, "", code)
}



#' Argument matching with defaults
#' 
#' This is a version of \code{\link{match.call}} which also includes default arguments.
#' 
#' @param definition a function, by default the function from which match.call is called. See details.
#' @param call an unevaluated call to the function specified by definition, as generated by call.
#' @param expand.dots Logical. Should arguments matching \code{...} in the call be included or left as a \code{...} argument?
#' @param envir an environment, from which the \code{...} in call are retrieved, if any.
#' 
#' @return An object of class call.
#' 
#' @author Neal Fultz
#' @references \url{http://stackoverflow.com/questions/14397364/match-call-with-default-arguments/}
#' @export
#' 
#' @examples 
#' 
#' foo <- function(x=NULL,y=NULL,z=4, dots=TRUE, ...) {
#'   match.call.defaults(expand.dots=dots)
#' }
#' 
#' foo(4,nugan='hand')
#' foo(dots=FALSE,who='ami')
#' 
match.call.defaults <- function(...) {
  call <- evalq(match.call(expand.dots = FALSE), parent.frame(1))
  formals <- evalq(formals(), parent.frame(1))
  
  for(i in setdiff(names(formals), names(call)))
    call[i] <- list( formals[[i]] )
  match.call(sys.function(sys.parent()), call)
}
