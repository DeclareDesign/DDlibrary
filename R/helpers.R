
# User-facing helpers -----------------------------------------------------

#' Get the code from a design
#' @param design A design that has code as an attribute.
#' @export
get_design_code <- function(design) attr(design, "code")


#' Argument matching with defaults
#' 
#' This is a version of \code{\link{match.call}} which also includes default arguments.
#' 
#' @param definition a function, by default the function from which match.call is called. See details.
#' @param call an unevaluated call to the function specified by definition, as generated by call.
#' @param expand.dots ogical. Should arguments matching \code{...} in the call be included or left as a \code{...} argument?
#' @param envir an environment, from which the \code{...} in call are retrieved, if any.
#' 
#' @return An object of class call.
#' 
#' @author Neal Fultz
#' @references \url{http://stackoverflow.com/questions/14397364/match-call-with-default-arguments/}
#' @export
#' 
#' @examples 
#' 
#' foo <- function(x=NULL,y=NULL,z=4, dots=TRUE, ...) {
#'   match.call.defaults(expand.dots=dots)
#' }
#' 
#' 

match.call.defaults <- function(definition = sys.function(sys.parent()),
                                call = sys.call(sys.parent()),
                                expand.dots = TRUE,
                                envir = parent.frame(2L)) {
  call <- match.call(definition, call, expand.dots, envir)
  formals <- formals(definition)
  
  if(expand.dots && '...' %in% names(formals))
    formals[['...']] <- NULL
  
  for(i in setdiff(names(formals), names(call)))
    call[i] <- list( formals[[i]] )
  
  
  match.call(definition, call, TRUE, envir)
}

# Internal helpers for {{{ }}} approach -----------------------------------

#' Author: Hadley Wickam
#' @importFrom rlang ensyms as_string
cement <- function(...) {
  args <- ensyms(...)
  paste(purrr::map(args, as_string), collapse = " ")
}

#' Replaces argument symbol in design code character vector with argument's value
#' @param argument A string. Design argument name.
#' @param replacement Design argument value.
#' @param string_vector A string vector.
#' @details It only replaces "N" argument for its value when N appears in the format "N = N". In these cases, the replacement is "N = 100" when the value of N is 100.
gsub_code_vector <- function(argument, replacement, string_vector){
  if(argument == "N"){
    replacement <- paste0("N = ", replacement)
    sapply(string_vector, function(s) gsub("N = N", replacement, s, fixed = TRUE), USE.NAMES = FALSE)
  } else {
    argument <- paste0("\\b", argument, "\\b(?!\\s*={1})")
    sapply(string_vector, function(s) gsub(argument, replacement, s, perl = TRUE), USE.NAMES = FALSE)
  }
}

# This is the core function for grabbing code when using the {{{ }}} approach:

#' Generates clean code string that reproduces design
#' @importFrom utils getSrcref
#' @importFrom rlang expr quo_text expr_text
#' @param designer Designer function.
#' @param args Named list of arguments to be passed to designer function.
#' @param fixed Vector of strings. Designer arguments to fix in design code.
#' @param arguments_as_values Logical. Whether to replace argument names for value.
#' @param exclude_args Vector of strings. Name of arguments to be excluded from argument definition at top of design code.

construct_design_code <- function(designer, args, fixed = NULL, arguments_as_values = FALSE, exclude_args = NULL){
  # get the code for the design 
  txt <- as.character(getSrcref(designer))
  if(length(txt)==0){
    txt <- find_triple_bracket(designer)
  }else{
    open <- grep("[{]{3}", txt)
    close <- grep("[}]{3}", txt)
    
    if(length(open) != 1) stop("could not find opening tag in ", substitute(designer))
    if(length(close) != 1) stop("could not find opening tag in ", substitute(designer))
    txt <- txt[seq(open + 1, close - 1)]
  }
  
  indentation <- strsplit(txt[1], "")[[1]]
  indentation <- indentation[cumprod(indentation == " ") == 1]
  indentation <- paste0("^", paste(indentation, collapse=""))
  
  code <- sub(indentation, "", txt)
  
  # Get names of arguments
  arg_names <- setdiff(names(args), "")
  
  # the following evaluates arguments all passed onto the function
  # it also allows evaluation of arguments of class `language` when they contain 
  # symbols were defined in previous arguments
  if(!is.null(arg_names)) {
    eval_envir <- new.env()
    args_eval <- lapply(1:length(arg_names), function(a){
      evaluated_arg <- invisible(eval(args[[arg_names[a]]], envir = eval_envir))
      invisible(assign(x = arg_names[a], value = evaluated_arg, envir = eval_envir))
      hold <- invisible(get(arg_names[a], envir = eval_envir))
      return(hold)
    })
    names(args_eval) <- arg_names
  }
  
  # If `arguments_as_values = TRUE`, assignment code replaces argument symbol with its (evaluated) value
  if(arguments_as_values){
    args_text <- sapply(1:length(args_eval), function(a){
      # if the argument is of class character and length 1, keep quotation marks
      # e.g., `name <- Y` is `name <- "Y"` 
      if (is.character(args_eval[[a]]) && length(args_eval[[a]]) == 1){
        arg_quoted <- paste0("\"", as.character(args_eval)[[a]], "\"")
        cement(!!(arg_names)[a], " <- ", !!arg_quoted)
      } else {
        cement(!!(arg_names)[a], " <- ", !!(as.character(args_eval)[[a]]))
      } 
    })
    
  } else {
    # convert (unevaluated) args to text
    args_text <- as.character(sapply(arg_names, function(x) paste0(x, " <- ", deparse(args[[x]]))))
  }
  
  #optionally fix arguments by replacing it with its (evaluated value)
  if(!is.null(fixed)){
    fixed <- setdiff(fixed, "fixed")
    for(i in 1:length(fixed)){
      replacement <- args_eval[[fixed[i]]]
      if(length(replacement) > 1) replacement <- expr_text(expr(!!replacement))
      code <- gsub_code_vector(fixed[i], replacement, code)
    }
  }
  
  # optionally exclude arguments
  if(!is.null(exclude_args)) args_text <- args_text[!(arg_names %in% exclude_args)]
  
  # add arguments and code
  code <- c(args_text, "", code)
  
  code
}

#' Generates character string for non-fixed arguments in a designer using substitution approach.
#' @param args Function arguments.
#' @param fixes Function arguments that are fixed (i.e., already evaluated in body of function)
#' 
return_args <- function(args, fixes){
  # Get names of arguments   
  arg_names <- names(args[2:(length(args)-1)])
  
  # Exclude any fixed arguments
  if(!is.null(fixes)) arg_names <- arg_names[!(arg_names%in%names(fixes))]
  
  # Format
  sapply(arg_names, function(x) paste0(x, " <- ", deparse(args[[x]])))
}

# These functions find triple braces when there is no source code 
find_triple_bracket <- function(f){
  clean <- function(ch, n=length(ch)-1) ch[2:n]
  ret <- Filter(pred, body(f))
  if(length(ret) == 0) "" else clean(deparse(ret[[1]][[2]][[2]]))
}
pred <- function(expr, depth=3) {
  (depth == 0) || (
    length(expr) > 1 &&
      expr[[1]] == as.symbol('{') &&
      Recall(expr[[2]], depth - 1)
  )
}

#' Clean code for method substitute
#' @param code A string. Design code
#' @return clean code 
clean_code <- function(code) {
  out <- strsplit(code, "\n")
  out <- out[-1]
  out <- gsub("#", " \n #", out)
  out
}

#' Substitute text from expressions in design code
#' @importFrom rlang get_expr quo_text list2 quos
#' @param argument_names Names of arguments that can be fixed in designer.
fixed_expr <- function(argument_names){
  txt1 <- paste0(argument_names, "_ <- ", argument_names, collapse = ";")
  txt2 <- paste0("if(!\"", argument_names, "\" %in% fixed) ", argument_names, "_ <- expr(", argument_names, ")", collapse = ";")
  return(c(txt1, txt2))
}

#' Substitute text from expressions in design code
#' @importFrom rlang get_expr quo_text list2 quos
#' @param code List contaitining design code.
#' @param ... List of expressions to be substituted for their text.
#' @return Code with expression text.
sub_expr_text <- function(code, ...){
  dots <- list2(...)
  qdots <- quos(...)
  exs <- sapply(1:length(dots), function(e) {
    ex <- get_expr(qdots[[e]])
    deparse(substitute(ex))
  })
  
  for(i in 1:length(dots)){
    to_sub <- paste0("eval_bare\\(", exs[i], "\\)")
    code <- gsub(to_sub, quo_text(dots[[i]]), code)
  }
  code
}