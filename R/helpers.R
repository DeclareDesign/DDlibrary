#' Get code from a designer
#' @param designer A function that builds designs, and contains the code to be grabbed inside triple braces
#' @return Verbatim code 
#' @export
#'
get_design_code <- function(design){
  attr(design, "code")
}

#' @export
construct_design_code <- function(designer, args){
  # get the code for the design 
  txt <- as.character(getSrcref(designer))
  if(length(txt)==0){
    txt <- deparse(designer)
    x <- grep("[{]", txt)
    open <- x[which(diff(x) == 1)]
    if(length(open)>3) stop("More than three consecutive `{` found in ", substitute(designer))
    open <- max(open)+1
    x <- grep("[}]", txt)
    close <- x[which(diff(x) == 1)]
    if(length(close)>2) stop("More than three consecutive `}` found in ", substitute(designer))
    close <- min(close)
  }else{
    open <- grep("[{]{3}", txt)
    close <- grep("[}]{3}", txt)
  }
  
  if(length(open) != 1) stop("could not find opening tag in ", substitute(designer))
  if(length(close) != 1) stop("could not find opening tag in ", substitute(designer))
  
  txt <- txt[seq(open + 1, close - 1)]
  
  indentation <- strsplit(txt[1], "")[[1]]
  indentation <- indentation[cumprod(indentation == " ") == 1]
  indentation <- paste0("^", paste(indentation, collapse=""))
  
  code <- sub(indentation, "", txt)
  
  # convert args to text
  args_text <- as.character(sapply(names(args[2:length(args)]), function(x) paste0(x, " <- ", deparse(args[[x]]))))
  
  # add arguments and code
  code <- c(args_text, "", code)
  
  code
}
#' Argument matching with defaults
#' 
#' This is a version of \code{\link{match.call}} which also includes default arguments.
#' 
#' @param definition a function, by default the function from which match.call is called. See details.
#' @param call an unevaluated call to the function specified by definition, as generated by call.
#' @param expand.dots ogical. Should arguments matching \code{...} in the call be included or left as a \code{...} argument?
#' @param envir an environment, from which the \code{...} in call are retrieved, if any.
#' 
#' @return An object of class call.
#' 
#' @author Neal Fultz
#' @references \url{http://stackoverflow.com/questions/14397364/match-call-with-default-arguments/}
#' @export
#' 
#' @examples 
#' 
#' foo <- function(x=NULL,y=NULL,z=4, dots=TRUE, ...) {
#'   match.call.defaults(expand.dots=dots)
#' }
#' 
#' foo(4,nugan='hand')
#' foo(dots=FALSE,who='ami')
#' 
match.call.defaults <- function(...) {
  call <- evalq(match.call(expand.dots = FALSE), parent.frame(1))
  formals <- evalq(formals(), parent.frame(1))
  
  for(i in setdiff(names(formals), names(call)))
    call[i] <- list( formals[[i]] )
  match.call(sys.function(sys.parent()), call)
}




#' Clean up DeclareDesign diagnosis object for printing 
#'
#' If diagnosands are bootstrapped, se's are put in parenthese on a second line and rounded to \code{digits}. 
#' Function uses presence of "se(" to identify bootrapped diagnoses; avoid errors by not using "se(" in naming of diagnosands. 
#'
#' @param diagnosis An object from \code{declare_design} 
#' @param digits Number of digits.
#' @param col.names Allows user to provide names of columns for output. If NULL uses names from diagnosis object, if "default" uses names of default diagnosands.
#' @param n_text_fields Number of initial text fields in diagnosis that do not have associated standard errors.  
#' @return A formatted text table with bootstrapped standard errors in parentheses.
#' @export
#'
#' @examples
#' # diagnosis <- diagnose_design(simple_two_arm_designer(), sims = 3)
#' # reshape_diagnosis(diagnosis)
#' # reshape_diagnosis(diagnosis, col.names = 1:11)
#' # reshape_diagnosis(diagnosis, col.names = "default")
#' # diagnosis <- diagnose_design(simple_two_arm_designer(), sims = 3, bootstrap = 0)
#' # reshape_diagnosis(diagnosis, col.names = "default")

reshape_diagnosis <- function(diagnosis, 
                              digits = 2, 
                              col.names = NULL, 
                              default.names = c("Estimator", "Coef Name", "Estimand", "Bias", "RMSE",  "Power", "Coverage", "Mean(Estimate)", "sd(Estimate)", "Mean(se)", "Type S", "Mean(Estimand)")
) { 
  
  # Housekeeping
  diagnosis     <- diagnosis[[2]]
  
  if(sum(grepl("se\\(", names(diagnosis))) == 0) { 
    out <- diagnosis
    if(is.null(col.names)) col.names <- colnames(out)
    
  } else {
    n_text_fields <- min(which(grepl("se\\(", names(diagnosis)))) - 2
    D             <- as.matrix(diagnosis[,(n_text_fields+1):ncol(diagnosis)])
    rows          <- nrow(D)
    
    cols       <- ncol(D)/2
    out.width  <- cols+n_text_fields
    
    # Reformatting
    out <- matrix(NA, 2*rows, out.width)
    out[2*(1:rows)-1, (n_text_fields + 1):ncol(out)] <- round(D[,2*(1:cols)-1], digits)
    out[2*(1:rows),   (n_text_fields + 1):ncol(out)] <- paste0("(", round(D[,2*(1:cols)], digits), ")")
    
    out[2*(1:rows)-1, 1:n_text_fields] <- as.matrix(diagnosis)[, 1:n_text_fields]
    out[2*(1:rows), 1:n_text_fields] <- " "
    if(is.null(col.names))        col.names <- colnames(diagnosis[,c(1:n_text_fields, n_text_fields+2*(1:cols)-1)])
    
  }
  
  # Column Names  
  if(col.names[1] == "default") col.names <- default.names  
  colnames(out) <- col.names
  
  return(out)
}

